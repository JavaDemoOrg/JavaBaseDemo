

## 线程（Thread）

1、sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，   
即使调用sleep方法，其他线程也无法访问这个对象。   

2、yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。     
它跟sleep方法类似，同样不会释放锁。但是yield不能控制具体的交出CPU的时间，    
另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。    
注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，    
它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。   

3、在Thread-1线程中，调用Thread-2的join方法，   
则Thread-1方法会等待Thread-2线程执行完毕或者等待一定的时间。   
join方法会让线程释放一个对象持有的锁。   

4、wait方法会让线程进入阻塞状态，并且会释放线程占有的锁，并交出CPU执行权限。   

5、interrupt方法可以使得处于阻塞状态的线程抛出一个异常，    
也就说，它可以用来中断一个正处于阻塞状态的线程；    
但是，直接调用interrupt方法不能中断正在运行中的线程；
另外，通过interrupt方法和isInterrupted()方法可以停止正在运行的线程。     
调用interrupt方法相当于将中断标志置为true，    
那么可以通过调用isInterrupted()判断中断标志来中断线程的执行。  

6、守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。     
举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，   
守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。    
在JVM中，像垃圾收集器线程就是守护线程。    


## 参考文献
[Java Thread 的使用](https://www.cnblogs.com/renhui/p/6066852.html)    

