
## ReentrantLock       
1、参考《轻松学习java可重入锁(ReentrantLock)的实现原理》     
2、

### 平锁模型        
初始化时，state=0，表示无人抢占了打水权。这时候，村民A来打水(A线程请求锁)，      
占了打水权，把state+1，如下所示：

线程A取得了锁，把state原子性+1，这时候state被改为1，A线程继续执行其他任务，       
然后来了村民B也想打水（线程B请求锁），线程B无法获取锁，生成节点进行排队，     
如下图所示：

初始化的时候，会生成一个空的头节点，然后才是B线程节点，这时候，     
如果线程A又请求锁，是否需要排队？答案当然是否定的，否则就直接死锁了。      
当A再次请求锁，就相当于是打水期间，同一家人也来打水了，是有特权的，       
这时候的状态如下图所示：

到了这里，相信大家应该明白了什么是可重入锁了吧。就是一个线程在获取了锁之后，      
再次去获取了同一个锁，这时候仅仅是把状态值进行累加。     
如果线程A释放了一次锁，就成这样了：

仅仅是把状态值减了，只有线程A把此锁全部释放了，状态值减到0了，   
其他线程才有机会获取锁。当A把锁完全释放后，state恢复为0，    
然后会通知队列唤醒B线程节点，使B可以再次竞争锁。当然，     
如果B线程后面还有C线程，C线程继续休眠，除非B执行完了，       
通知了C线程。注意，当一个线程节点被唤醒然后取得了锁，对应节点会从队列中删除。 

### 非公平锁模型
如果你已经明白了前面讲的公平锁模型，那么非公平锁模型也就非常容易理解了。     
当线程A执行完之后，要唤醒线程B是需要时间的，而且线程B醒来后还要再次竞争锁，     
所以如果在切换过程当中，来了一个线程C，那么线程C是有可能获取到锁的，       
如果C获取到了锁，B就只能继续乖乖休眠了。这里就不再画图说明了。    

## 参考文献    
1、[JDK5.0中更灵活、更具可伸缩性的锁定机制](https://www.ibm.com/developerworks/cn/java/j-jtp10264/index.html)         
2、[轻松学习java可重入锁(ReentrantLock)的实现原理](https://blog.csdn.net/yanyan19880509/article/details/52345422)      
